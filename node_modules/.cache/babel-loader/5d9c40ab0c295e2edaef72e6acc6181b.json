{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _actions = require('@appbaseio/reactivecore/lib/actions');\n\nvar _hoistNonReactStatics = require('hoist-non-react-statics');\n\nvar _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);\n\nvar _helper = require('@appbaseio/reactivecore/lib/utils/helper');\n\nvar _types = require('@appbaseio/reactivecore/lib/utils/types');\n\nvar _types2 = _interopRequireDefault(_types);\n\nvar _Slider = require('rheostat/lib/Slider');\n\nvar _Slider2 = _interopRequireDefault(_Slider);\n\nvar _HistogramContainer = require('./addons/HistogramContainer');\n\nvar _HistogramContainer2 = _interopRequireDefault(_HistogramContainer);\n\nvar _RangeLabel = require('./addons/RangeLabel');\n\nvar _RangeLabel2 = _interopRequireDefault(_RangeLabel);\n\nvar _SliderHandle = require('./addons/SliderHandle');\n\nvar _SliderHandle2 = _interopRequireDefault(_SliderHandle);\n\nvar _Slider3 = require('../../styles/Slider');\n\nvar _Slider4 = _interopRequireDefault(_Slider3);\n\nvar _Title = require('../../styles/Title');\n\nvar _Title2 = _interopRequireDefault(_Title);\n\nvar _Label = require('../../styles/Label');\n\nvar _utils = require('../../utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar DynamicRangeSlider = function (_Component) {\n  _inherits(DynamicRangeSlider, _Component);\n\n  function DynamicRangeSlider(props) {\n    _classCallCheck(this, DynamicRangeSlider);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    _initialiseProps.call(_this);\n\n    _this.state = {\n      currentValue: null,\n      range: null,\n      stats: []\n    };\n    _this.internalHistogramComponent = _this.props.componentId + '__histogram__internal';\n    _this.internalRangeComponent = _this.props.componentId + '__range__internal';\n    _this.internalMatchAllComponent = _this.props.componentId + '__match_all__internal';\n    _this.locked = false;\n    props.addComponent(props.componentId);\n    props.addComponent(_this.internalHistogramComponent);\n    props.addComponent(_this.internalRangeComponent);\n    props.setQueryListener(props.componentId, props.onQueryChange, null); // get range before executing other queries\n\n    _this.updateRangeQueryOptions(props);\n\n    _this.setReact(props);\n\n    return _this;\n  }\n\n  DynamicRangeSlider.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this2 = this;\n\n    if (!(0, _helper.isEqual)(this.props.range, prevProps.range) && this.props.range) {\n      // when range prop is changed\n      // it will happen due to initial mount (or) due to subscription\n      this.updateQueryOptions(this.props, this.props.range); // floor and ceil to take edge cases into account\n\n      this.updateRange({\n        start: Math.floor(this.props.range.start),\n        end: Math.ceil(this.props.range.end)\n      });\n      var value = this.props.value || this.props.defaultValue; // only listen to selectedValue initially, after the\n      // component has mounted and range is received\n\n      if (this.props.selectedValue && !this.state.currentValue) {\n        this.handleChange(this.props.selectedValue);\n      } else if (value) {\n        var _value = value(this.props.range.start, this.props.range.end),\n            start = _value.start,\n            end = _value.end;\n\n        this.handleChange([start, end]);\n      } else {\n        this.handleChange([Math.floor(this.props.range.start), Math.ceil(this.props.range.end)]);\n      }\n    } else if (this.props.range && !(0, _helper.isEqual)(this.props.value && this.props.value(this.props.range.start, this.props.range.end), prevProps.value && prevProps.value(this.props.range.start, this.props.range.end))) {\n      // when value prop is changed\n      var _props$value = this.props.value(this.props.range.start, this.props.range.end),\n          _start = _props$value.start,\n          _end = _props$value.end;\n\n      this.handleChange([_start, _end]);\n    } else if (this.props.range && this.props.selectedValue === null && prevProps.selectedValue) {\n      // when the filter is reset\n      this.handleChange([this.props.range.start, this.props.range.end]);\n    }\n\n    (0, _helper.checkPropChange)(this.props.react, prevProps.react, function () {\n      _this2.updateRangeQueryOptions(_this2.props);\n\n      _this2.setReact(_this2.props);\n    });\n    (0, _helper.checkSomePropChange)(this.props, prevProps, ['dataField', 'nestedField'], function () {\n      _this2.updateRangeQueryOptions(_this2.props);\n    });\n    (0, _helper.checkSomePropChange)(this.props, prevProps, ['showHistogram', 'interval'], function () {\n      return _this2.updateQueryOptions(_this2.props, _this2.props.range || _this2.state.range);\n    });\n    (0, _helper.checkPropChange)(this.props.options, prevProps.options, function () {\n      var options = _this2.props.options;\n      options.sort(function (a, b) {\n        if (a.key < b.key) return -1;\n        if (a.key > b.key) return 1;\n        return 0;\n      });\n\n      _this2.setState({\n        stats: options\n      });\n    });\n  };\n\n  DynamicRangeSlider.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    if (nextState.range) {\n      var upperLimit = Math.floor((nextState.range.end - nextState.range.start) / 2);\n\n      if (nextProps.stepValue < 1 || nextProps.stepValue > upperLimit) {\n        console.warn('stepValue for DynamicRangeSlider ' + nextProps.componentId + ' should be greater than 0 and less than or equal to ' + upperLimit);\n        return false;\n      }\n\n      return true;\n    }\n\n    return true;\n  };\n\n  DynamicRangeSlider.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.props.removeComponent(this.props.componentId);\n    this.props.removeComponent(this.internalHistogramComponent);\n    this.props.removeComponent(this.internalRangeComponent);\n    this.props.removeComponent(this.internalMatchAllComponent);\n  }; // value parser for SSR\n\n\n  DynamicRangeSlider.prototype.renderHistogram = function renderHistogram() {\n    if (this.props.isLoading && this.props.loader) {\n      return this.props.loader;\n    }\n\n    if (this.state.stats.length && this.props.showHistogram) {\n      return _react2.default.createElement(_HistogramContainer2.default, {\n        stats: this.state.stats,\n        range: this.state.range,\n        interval: this.getValidInterval(this.props, this.state.range)\n      });\n    }\n\n    return null;\n  };\n\n  DynamicRangeSlider.prototype.render = function render() {\n    var _this3 = this;\n\n    if (!this.state.currentValue || !this.state.range) {\n      return null;\n    }\n\n    var _getRangeLabels = this.getRangeLabels(),\n        startLabel = _getRangeLabels.startLabel,\n        endLabel = _getRangeLabels.endLabel;\n\n    return _react2.default.createElement(_Slider4.default, {\n      primary: true,\n      style: this.props.style,\n      className: this.props.className\n    }, this.props.title && _react2.default.createElement(_Title2.default, {\n      className: (0, _helper.getClassName)(this.props.innerClass, 'title') || null\n    }, this.props.title), this.renderHistogram(), _react2.default.createElement(_Slider2.default, {\n      min: this.state.range.start,\n      max: this.state.range.end,\n      values: this.state.currentValue,\n      onChange: this.handleSlider,\n      onValuesUpdated: this.handleDrag,\n      snap: this.props.snap,\n      snapPoints: this.props.snap ? this.getSnapPoints() : null,\n      className: (0, _helper.getClassName)(this.props.innerClass, 'slider'),\n      handle: function handle(_ref) {\n        var className = _ref.className,\n            style = _ref.style,\n            passProps = _objectWithoutProperties(_ref, ['className', 'style']);\n\n        return _react2.default.createElement(_SliderHandle2.default, _extends({\n          style: style,\n          className: className\n        }, passProps, {\n          renderTooltipData: _this3.props.renderTooltipData,\n          tooltipTrigger: _this3.props.tooltipTrigger\n        }));\n      }\n    }), _react2.default.createElement('div', {\n      className: _Label.rangeLabelsContainer\n    }, _react2.default.createElement(_RangeLabel2.default, {\n      align: 'left',\n      className: (0, _helper.getClassName)(this.props.innerClass, 'label') || null\n    }, startLabel), _react2.default.createElement(_RangeLabel2.default, {\n      align: 'right',\n      className: (0, _helper.getClassName)(this.props.innerClass, 'label') || null\n    }, endLabel)));\n  };\n\n  return DynamicRangeSlider;\n}(_react.Component);\n\nDynamicRangeSlider.parseValue = function (value) {\n  if (Array.isArray(value)) return value;\n  return value ? [value().start, value().end] : null;\n};\n\nDynamicRangeSlider.defaultQuery = function (value, props) {\n  var query = null;\n\n  if (Array.isArray(value) && value.length) {\n    var _range;\n\n    query = {\n      range: (_range = {}, _range[props.dataField] = {\n        gte: value[0],\n        lte: value[1],\n        boost: 2.0\n      }, _range)\n    };\n  }\n\n  if (query && props.nestedField) {\n    return {\n      query: {\n        nested: {\n          path: props.nestedField,\n          query: query\n        }\n      }\n    };\n  }\n\n  return query;\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this4 = this;\n\n  this.setReact = function (props) {\n    var react = props.react;\n\n    if (react) {\n      props.watchComponent(_this4.internalRangeComponent, props.react);\n      var newReact = (0, _helper.pushToAndClause)(react, _this4.internalHistogramComponent);\n      props.watchComponent(props.componentId, newReact);\n    } else {\n      // internalRangeComponent watches internalMatchAll component allowing execution of query\n      // in case of no react prop\n      _this4.props.addComponent(_this4.internalMatchAllComponent);\n\n      props.setQueryOptions(_this4.internalMatchAllComponent, {\n        aggs: {\n          match_all: {}\n        }\n      }, false);\n      props.watchComponent(_this4.internalRangeComponent, {\n        and: _this4.internalMatchAllComponent\n      });\n      props.watchComponent(props.componentId, {\n        and: _this4.internalHistogramComponent\n      });\n    }\n  };\n\n  this.getSnapPoints = function () {\n    var snapPoints = [];\n    var stepValue = _this4.props.stepValue;\n    var range = _this4.state.range; // limit the number of steps to prevent generating a large number of snapPoints\n\n    if ((range.end - range.start) / stepValue > 100) {\n      stepValue = (range.end - range.start) / 100;\n    }\n\n    for (var i = range.start; i <= range.end; i += stepValue) {\n      snapPoints = snapPoints.concat(i);\n    }\n\n    if (snapPoints[snapPoints.length - 1] !== range.end) {\n      snapPoints = snapPoints.concat(range.end);\n    }\n\n    return snapPoints;\n  };\n\n  this.getValidInterval = function (props, range) {\n    var min = Math.ceil((range.end - range.start) / 100) || 1;\n\n    if (!props.interval) {\n      return min;\n    } else if (props.interval < min) {\n      console.error(props.componentId + ': interval prop\\'s value should be greater than or equal to ' + min);\n      return min;\n    }\n\n    return props.interval;\n  };\n\n  this.histogramQuery = function (props, range) {\n    var _ref2;\n\n    return _ref2 = {}, _ref2[props.dataField] = {\n      histogram: {\n        field: props.dataField,\n        interval: _this4.getValidInterval(props, range),\n        offset: range.start\n      }\n    }, _ref2;\n  };\n\n  this.rangeQuery = function (props) {\n    return {\n      min: {\n        min: {\n          field: props.dataField\n        }\n      },\n      max: {\n        max: {\n          field: props.dataField\n        }\n      }\n    };\n  };\n\n  this.handleChange = function (currentValue) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this4.props; // ignore state updates when component is locked\n\n    if (props.beforeValueChange && _this4.locked) {\n      return;\n    } // always keep the values within range\n\n\n    var normalizedValue = [currentValue[0] < props.range.start ? props.range.start : currentValue[0], currentValue[1] > props.range.end ? props.range.end : currentValue[1]];\n    _this4.locked = true;\n\n    var performUpdate = function performUpdate() {\n      _this4.setState({\n        currentValue: normalizedValue\n      }, function () {\n        var normalizedValues = [normalizedValue[0], normalizedValue[1]];\n\n        _this4.updateQuery(normalizedValues, props);\n\n        _this4.locked = false;\n        if (props.onValueChange) props.onValueChange(normalizedValues);\n      });\n    };\n\n    (0, _helper.checkValueChange)(props.componentId, {\n      start: normalizedValue[0],\n      end: normalizedValue[1]\n    }, props.beforeValueChange, performUpdate);\n  };\n\n  this.handleSlider = function (_ref3) {\n    var values = _ref3.values;\n\n    if (!(0, _helper.isEqual)(values, _this4.state.currentValue)) {\n      var _props = _this4.props,\n          value = _props.value,\n          onChange = _props.onChange;\n\n      if (value === undefined) {\n        _this4.handleChange(values);\n      } else if (onChange) {\n        onChange(values);\n      } else {\n        _this4.handleChange(values);\n      }\n    }\n  };\n\n  this.handleDrag = function (values) {\n    if (_this4.props.onDrag) {\n      var min = values.min,\n          max = values.max,\n          currentValue = values.values;\n\n      _this4.props.onDrag(currentValue, [min, max]);\n    }\n  };\n\n  this.updateQuery = function (value, props) {\n    var customQuery = props.customQuery;\n    var query = DynamicRangeSlider.defaultQuery(value, props);\n    var customQueryOptions = void 0;\n\n    if (customQuery) {\n      var _ref4 = customQuery(value, props) || {};\n\n      query = _ref4.query;\n      customQueryOptions = (0, _helper.getOptionsFromQuery)(customQuery(value, props));\n    }\n\n    var showFilter = props.showFilter,\n        _props$range = props.range,\n        start = _props$range.start,\n        end = _props$range.end;\n    var currentStart = value[0],\n        currentEnd = value[1]; // check if the slider is at its initial position\n\n    var isInitialValue = currentStart === start && currentEnd === end;\n    props.setQueryOptions(props.componentId, customQueryOptions);\n    props.updateQuery({\n      componentId: props.componentId,\n      query: query,\n      value: value,\n      label: props.filterLabel,\n      showFilter: showFilter && !isInitialValue,\n      URLParams: props.URLParams,\n      componentType: 'DYNAMICRANGESLIDER'\n    });\n  };\n\n  this.updateQueryOptions = function (props, range) {\n    if (props.showHistogram) {\n      var queryOptions = {\n        aggs: _this4.histogramQuery(props, range)\n      };\n      var customQuery = props.customQuery;\n      var query = props.customQuery || DynamicRangeSlider.defaultQuery;\n      var value = [range.start, range.end];\n      var customQueryOptions = customQuery ? (0, _helper.getOptionsFromQuery)(customQuery(value, props)) : null;\n      props.setQueryOptions(_this4.internalHistogramComponent, _extends({}, queryOptions, customQueryOptions), false);\n      props.updateQuery({\n        componentId: _this4.internalHistogramComponent,\n        query: query(value, props)\n      });\n    }\n  };\n\n  this.updateRange = function (range) {\n    _this4.setState({\n      range: range\n    });\n  };\n\n  this.updateRangeQueryOptions = function (props) {\n    var queryOptions = {};\n    var nestedField = props.nestedField;\n\n    if (nestedField) {\n      var _aggs;\n\n      queryOptions = {\n        aggs: (_aggs = {}, _aggs[nestedField] = {\n          nested: {\n            path: nestedField\n          },\n          aggs: _this4.rangeQuery(props)\n        }, _aggs)\n      };\n    } else {\n      queryOptions = {\n        aggs: _this4.rangeQuery(props)\n      };\n    }\n\n    props.setQueryOptions(_this4.internalRangeComponent, queryOptions);\n  };\n\n  this.getRangeLabels = function () {\n    var _state$range = _this4.state.range,\n        startLabel = _state$range.start,\n        endLabel = _state$range.end;\n\n    if (_this4.props.rangeLabels) {\n      var rangeLabels = _this4.props.rangeLabels(_this4.props.range.start, _this4.props.range.end);\n\n      startLabel = rangeLabels.start;\n      endLabel = rangeLabels.end;\n    }\n\n    return {\n      startLabel: startLabel,\n      endLabel: endLabel\n    };\n  };\n};\n\nDynamicRangeSlider.propTypes = {\n  addComponent: _types2.default.funcRequired,\n  removeComponent: _types2.default.funcRequired,\n  setQueryListener: _types2.default.funcRequired,\n  setQueryOptions: _types2.default.funcRequired,\n  updateQuery: _types2.default.funcRequired,\n  watchComponent: _types2.default.funcRequired,\n  options: _types2.default.options,\n  range: _types2.default.range,\n  selectedValue: _types2.default.selectedValue,\n  // component props\n  beforeValueChange: _types2.default.func,\n  className: _types2.default.string,\n  componentId: _types2.default.stringRequired,\n  customQuery: _types2.default.func,\n  dataField: _types2.default.stringRequired,\n  defaultValue: _types2.default.func,\n  value: _types2.default.func,\n  filterLabel: _types2.default.string,\n  innerClass: _types2.default.style,\n  interval: _types2.default.number,\n  isLoading: _types2.default.bool,\n  loader: _types2.default.title,\n  nestedField: _types2.default.string,\n  onDrag: _types2.default.func,\n  onQueryChange: _types2.default.func,\n  onValueChange: _types2.default.func,\n  onChange: _types2.default.func,\n  rangeLabels: _types2.default.func,\n  react: _types2.default.react,\n  showHistogram: _types2.default.bool,\n  showFilter: _types2.default.bool,\n  tooltipTrigger: _types2.default.tooltipTrigger,\n  renderTooltipData: _types2.default.func,\n  snap: _types2.default.bool,\n  stepValue: _types2.default.number,\n  style: _types2.default.style,\n  title: _types2.default.title,\n  URLParams: _types2.default.bool\n};\nDynamicRangeSlider.defaultProps = {\n  className: null,\n  showHistogram: true,\n  tooltipTrigger: 'none',\n  snap: true,\n  stepValue: 1,\n  style: {},\n  URLParams: false,\n  showFilter: true\n};\n\nvar mapStateToProps = function mapStateToProps(state, props) {\n  var options = state.aggregations[props.componentId] && state.aggregations[props.componentId][props.dataField];\n  var range = state.aggregations[props.componentId + '__range__internal'];\n\n  if (props.nestedField) {\n    options = options && state.aggregations[props.componentId][props.dataField][props.nestedField] && state.aggregations[props.componentId][props.dataField][props.nestedField].buckets ? state.aggregations[props.componentId][props.dataField][props.nestedField].buckets : [];\n    range = range && state.aggregations[props.componentId + '__range__internal'][props.nestedField].min ? {\n      start: state.aggregations[props.componentId + '__range__internal'][props.nestedField].min.value,\n      end: state.aggregations[props.componentId + '__range__internal'][props.nestedField].max.value // prettier-ignore\n\n    } : null;\n  } else {\n    options = options && state.aggregations[props.componentId][props.dataField].buckets ? state.aggregations[props.componentId][props.dataField].buckets : [];\n    range = range && state.aggregations[props.componentId + '__range__internal'].min ? {\n      start: state.aggregations[props.componentId + '__range__internal'].min.value,\n      end: state.aggregations[props.componentId + '__range__internal'].max.value // prettier-ignore\n\n    } : null;\n  }\n\n  return {\n    options: options,\n    isLoading: state.isLoading[props.componentId],\n    range: range,\n    selectedValue: state.selectedValues[props.componentId] ? state.selectedValues[props.componentId].value : null\n  };\n};\n\nvar mapDispatchtoProps = function mapDispatchtoProps(dispatch) {\n  return {\n    addComponent: function addComponent(component) {\n      return dispatch((0, _actions.addComponent)(component));\n    },\n    removeComponent: function removeComponent(component) {\n      return dispatch((0, _actions.removeComponent)(component));\n    },\n    setQueryOptions: function setQueryOptions(component, props, execute) {\n      return dispatch((0, _actions.setQueryOptions)(component, props, execute));\n    },\n    setQueryListener: function setQueryListener(component, onQueryChange, beforeQueryChange) {\n      return dispatch((0, _actions.setQueryListener)(component, onQueryChange, beforeQueryChange));\n    },\n    updateQuery: function updateQuery(updateQueryObject) {\n      return dispatch((0, _actions.updateQuery)(updateQueryObject));\n    },\n    watchComponent: function watchComponent(component, react) {\n      return dispatch((0, _actions.watchComponent)(component, react));\n    }\n  };\n};\n\nvar ConnectedComponent = (0, _utils.connect)(mapStateToProps, mapDispatchtoProps)(function (props) {\n  return _react2.default.createElement(DynamicRangeSlider, _extends({\n    ref: props.myForwardedRef\n  }, props));\n}); // eslint-disable-next-line\n\nvar ForwardRefComponent = _react2.default.forwardRef(function (props, ref) {\n  return _react2.default.createElement(ConnectedComponent, _extends({}, props, {\n    myForwardedRef: ref\n  }));\n});\n\n(0, _hoistNonReactStatics2.default)(ForwardRefComponent, DynamicRangeSlider);\nForwardRefComponent.name = 'DynamicRangeSlider';\nexports.default = ForwardRefComponent;","map":null,"metadata":{},"sourceType":"script"}